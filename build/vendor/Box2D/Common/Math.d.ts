export declare const degToRad: number;
export declare const radToDeg: number;
export declare const two_pi: number;
export declare const Abs: (x: number) => number;
export declare const Min: (...values: number[]) => number;
export declare const Max: (...values: number[]) => number;
export declare function Clamp(a: number, lo: number, hi: number): number;
export declare function Swap<T>(a: T[], b: T[]): void;
export declare const IsValid: typeof isFinite;
export declare function Sq(n: number): number;
export declare function InvSqrt(n: number): number;
export declare const Sqrt: (x: number) => number;
export declare const Pow: (x: number, y: number) => number;
export declare function DegToRad(degrees: number): number;
export declare function RadToDeg(radians: number): number;
export declare const Cos: (x: number) => number;
export declare const Sin: (x: number) => number;
export declare const Acos: (x: number) => number;
export declare const Asin: (x: number) => number;
export declare const Atan2: (y: number, x: number) => number;
export declare function NextPowerOfTwo(x: number): number;
export declare function IsPowerOfTwo(x: number): boolean;
export declare function Random(): number;
export declare function RandomRange(lo: number, hi: number): number;
export interface XY {
    x: number;
    y: number;
}
export declare class Vec2 implements XY {
    static readonly ZERO: Readonly<Vec2>;
    static readonly UNITX: Readonly<Vec2>;
    static readonly UNITY: Readonly<Vec2>;
    static readonly s_t0: Vec2;
    static readonly s_t1: Vec2;
    static readonly s_t2: Vec2;
    static readonly s_t3: Vec2;
    static MakeArray(length: number): Vec2[];
    static AbsV<T extends XY>(v: XY, out: T): T;
    static MinV<T extends XY>(a: XY, b: XY, out: T): T;
    static MaxV<T extends XY>(a: XY, b: XY, out: T): T;
    static ClampV<T extends XY>(v: XY, lo: XY, hi: XY, out: T): T;
    static RotateV<T extends XY>(v: XY, radians: number, out: T): T;
    static DotVV(a: XY, b: XY): number;
    static CrossVV(a: XY, b: XY): number;
    static CrossVS<T extends XY>(v: XY, s: number, out: T): T;
    static CrossVOne<T extends XY>(v: XY, out: T): T;
    static CrossSV<T extends XY>(s: number, v: XY, out: T): T;
    static CrossOneV<T extends XY>(v: XY, out: T): T;
    static AddVV<T extends XY>(a: XY, b: XY, out: T): T;
    static SubVV<T extends XY>(a: XY, b: XY, out: T): T;
    static MulSV<T extends XY>(s: number, v: XY, out: T): T;
    static MulVS<T extends XY>(v: XY, s: number, out: T): T;
    static AddVMulSV<T extends XY>(a: XY, s: number, b: XY, out: T): T;
    static SubVMulSV<T extends XY>(a: XY, s: number, b: XY, out: T): T;
    static AddVCrossSV<T extends XY>(a: XY, s: number, v: XY, out: T): T;
    static MidVV<T extends XY>(a: XY, b: XY, out: T): T;
    static ExtVV<T extends XY>(a: XY, b: XY, out: T): T;
    static IsEqualToV(a: XY, b: XY): boolean;
    static DistanceVV(a: XY, b: XY): number;
    static DistanceSquaredVV(a: XY, b: XY): number;
    static NegV<T extends XY>(v: XY, out: T): T;
    x: number;
    y: number;
    constructor(x?: number, y?: number);
    Clone(): Vec2;
    SetZero(): this;
    Set(x: number, y: number): this;
    Copy(other: XY): this;
    SelfAdd(v: XY): this;
    SelfAddXY(x: number, y: number): this;
    SelfSub(v: XY): this;
    SelfSubXY(x: number, y: number): this;
    SelfMul(s: number): this;
    SelfMulAdd(s: number, v: XY): this;
    SelfMulSub(s: number, v: XY): this;
    Dot(v: XY): number;
    Cross(v: XY): number;
    Length(): number;
    LengthSquared(): number;
    Normalize(): number;
    SelfNormalize(): this;
    SelfRotate(radians: number): this;
    SelfRotateCosSin(c: number, s: number): this;
    IsValid(): boolean;
    SelfCrossVS(s: number): this;
    SelfCrossSV(s: number): this;
    SelfMinV(v: XY): this;
    SelfMaxV(v: XY): this;
    SelfAbs(): this;
    SelfNeg(): this;
    SelfSkew(): this;
}
export declare const Vec2_zero: Readonly<Vec2>;
export interface XYZ extends XY {
    z: number;
}
export declare class Vec3 implements XYZ {
    static readonly ZERO: Readonly<Vec3>;
    static readonly s_t0: Vec3;
    static DotV3V3(a: XYZ, b: XYZ): number;
    static CrossV3V3<T extends XYZ>(a: XYZ, b: XYZ, out: T): T;
    x: number;
    y: number;
    z: number;
    constructor(x?: number, y?: number, z?: number);
    Clone(): Vec3;
    SetZero(): this;
    SetXYZ(x: number, y: number, z: number): this;
    Copy(other: XYZ): this;
    SelfNeg(): this;
    SelfAdd(v: XYZ): this;
    SelfAddXYZ(x: number, y: number, z: number): this;
    SelfSub(v: XYZ): this;
    SelfSubXYZ(x: number, y: number, z: number): this;
    SelfMul(s: number): this;
}
export declare class Mat22 {
    static readonly IDENTITY: Readonly<Mat22>;
    static FromVV(c1: XY, c2: XY): Mat22;
    static FromSSSS(r1c1: number, r1c2: number, r2c1: number, r2c2: number): Mat22;
    static FromAngle(radians: number): Mat22;
    static AbsM(M: Mat22, out: Mat22): Mat22;
    static MulMV<T extends XY>(M: Mat22, v: XY, out: T): T;
    static MulTMV<T extends XY>(M: Mat22, v: XY, out: T): T;
    static AddMM(A: Mat22, B: Mat22, out: Mat22): Mat22;
    static MulMM(A: Mat22, B: Mat22, out: Mat22): Mat22;
    static MulTMM(A: Mat22, B: Mat22, out: Mat22): Mat22;
    readonly ex: Vec2;
    readonly ey: Vec2;
    Clone(): Mat22;
    SetSSSS(r1c1: number, r1c2: number, r2c1: number, r2c2: number): this;
    SetVV(c1: XY, c2: XY): this;
    SetAngle(radians: number): this;
    Copy(other: Mat22): this;
    SetIdentity(): this;
    SetZero(): this;
    GetAngle(): number;
    GetInverse(out: Mat22): Mat22;
    Solve<T extends XY>(b_x: number, b_y: number, out: T): T;
    SelfAbs(): this;
    SelfInv(): this;
    SelfAddM(M: Mat22): this;
    SelfSubM(M: Mat22): this;
}
export declare class Mat33 {
    static readonly IDENTITY: Readonly<Mat33>;
    static MulM33V3<T extends XYZ>(A: Mat33, v: XYZ, out: T): T;
    static MulM33XYZ<T extends XYZ>(A: Mat33, x: number, y: number, z: number, out: T): T;
    static MulM33V2<T extends XY>(A: Mat33, v: XY, out: T): T;
    static MulM33XY<T extends XY>(A: Mat33, x: number, y: number, out: T): T;
    readonly ex: Vec3;
    readonly ey: Vec3;
    readonly ez: Vec3;
    Clone(): Mat33;
    SetVVV(c1: XYZ, c2: XYZ, c3: XYZ): this;
    Copy(other: Mat33): this;
    SetIdentity(): this;
    SetZero(): this;
    SelfAddM(M: Mat33): this;
    Solve33<T extends XYZ>(b_x: number, b_y: number, b_z: number, out: T): T;
    Solve22<T extends XY>(b_x: number, b_y: number, out: T): T;
    GetInverse22(M: Mat33): void;
    GetSymInverse33(M: Mat33): void;
}
export declare class Rot {
    static readonly IDENTITY: Readonly<Rot>;
    static MulRR(q: Rot, r: Rot, out: Rot): Rot;
    static MulTRR(q: Rot, r: Rot, out: Rot): Rot;
    static MulRV<T extends XY>(q: Rot, v: XY, out: T): T;
    static MulTRV<T extends XY>(q: Rot, v: XY, out: T): T;
    s: number;
    c: number;
    constructor(angle?: number);
    Clone(): Rot;
    Copy(other: Rot): this;
    SetAngle(angle: number): this;
    SetIdentity(): this;
    GetAngle(): number;
    GetXAxis<T extends XY>(out: T): T;
    GetYAxis<T extends XY>(out: T): T;
}
export declare class Transform {
    static readonly IDENTITY: Readonly<Transform>;
    static MulXV<T extends XY>(T: Transform, v: XY, out: T): T;
    static MulTXV<T extends XY>(T: Transform, v: XY, out: T): T;
    static MulXX(A: Transform, B: Transform, out: Transform): Transform;
    static MulTXX(A: Transform, B: Transform, out: Transform): Transform;
    readonly p: Vec2;
    readonly q: Rot;
    Clone(): Transform;
    Copy(other: Transform): this;
    SetIdentity(): this;
    SetPositionRotation(position: XY, q: Readonly<Rot>): this;
    SetPositionAngle(pos: XY, a: number): this;
    SetPosition(position: XY): this;
    SetPositionXY(x: number, y: number): this;
    SetRotation(rotation: Readonly<Rot>): this;
    SetRotationAngle(radians: number): this;
    GetPosition(): Readonly<Vec2>;
    GetRotation(): Readonly<Rot>;
    GetRotationAngle(): number;
    GetAngle(): number;
}
export declare class Sweep {
    readonly localCenter: Vec2;
    readonly c0: Vec2;
    readonly c: Vec2;
    a0: number;
    a: number;
    alpha0: number;
    Clone(): Sweep;
    Copy(other: Sweep): this;
    GetTransform(xf: Transform, beta: number): Transform;
    Advance(alpha: number): void;
    Normalize(): void;
}
