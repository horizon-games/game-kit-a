import { MassData, Shape } from '../Collision/Shapes/Shape';
import { Sweep, Transform, Vec2, XY } from '../Common/Math';
import { ControllerEdge } from '../Controllers/Controller';
import { ContactEdge } from './Contacts/Contact';
import { Fixture, IFixtureDef } from './Fixture';
import { JointEdge } from './Joints/Joint';
import { World } from './World';
export declare enum BodyType {
    unknown = -1,
    staticBody = 0,
    kinematicBody = 1,
    dynamicBody = 2
}
export interface IBodyDef {
    type?: BodyType;
    position?: XY;
    angle?: number;
    linearVelocity?: XY;
    angularVelocity?: number;
    linearDamping?: number;
    angularDamping?: number;
    allowSleep?: boolean;
    awake?: boolean;
    fixedRotation?: boolean;
    bullet?: boolean;
    active?: boolean;
    userData?: any;
    gravityScale?: number;
}
export declare class BodyDef implements IBodyDef {
    type: BodyType;
    readonly position: Vec2;
    angle: number;
    readonly linearVelocity: Vec2;
    angularVelocity: number;
    linearDamping: number;
    angularDamping: number;
    allowSleep: boolean;
    awake: boolean;
    fixedRotation: boolean;
    bullet: boolean;
    active: boolean;
    userData: any;
    gravityScale: number;
}
export declare class Body {
    private static CreateFixtureShapeDensity_s_def;
    private static SetMassData_s_oldCenter;
    private static ResetMassData_s_localCenter;
    private static ResetMassData_s_oldCenter;
    private static ResetMassData_s_massData;
    private static SynchronizeFixtures_s_xf1;
    m_type: BodyType;
    m_islandFlag: boolean;
    m_awakeFlag: boolean;
    m_autoSleepFlag: boolean;
    m_bulletFlag: boolean;
    m_fixedRotationFlag: boolean;
    m_activeFlag: boolean;
    m_toiFlag: boolean;
    m_islandIndex: number;
    readonly m_xf: Transform;
    readonly m_xf0: Transform;
    readonly m_sweep: Sweep;
    readonly m_linearVelocity: Vec2;
    m_angularVelocity: number;
    readonly m_force: Vec2;
    m_torque: number;
    m_world: World;
    m_prev: Body | null;
    m_next: Body | null;
    m_fixtureList: Fixture | null;
    m_fixtureCount: number;
    m_jointList: JointEdge | null;
    m_contactList: ContactEdge | null;
    m_mass: number;
    m_invMass: number;
    m_I: number;
    m_invI: number;
    m_linearDamping: number;
    m_angularDamping: number;
    m_gravityScale: number;
    m_sleepTime: number;
    m_userData: any;
    m_controllerList: ControllerEdge | null;
    m_controllerCount: number;
    constructor(bd: IBodyDef, world: World);
    CreateFixture(a: IFixtureDef | Shape, b?: number): Fixture;
    CreateFixtureDef(def: IFixtureDef): Fixture;
    CreateFixtureShapeDensity(shape: Shape, density?: number): Fixture;
    DestroyFixture(fixture: Fixture): void;
    SetTransformVec(position: XY, angle: number): void;
    SetTransformXY(x: number, y: number, angle: number): void;
    SetTransform(xf: Transform): void;
    GetTransform(): Readonly<Transform>;
    GetPosition(): Readonly<Vec2>;
    SetPosition(position: XY): void;
    SetPositionXY(x: number, y: number): void;
    GetAngle(): number;
    SetAngle(angle: number): void;
    GetWorldCenter(): Readonly<Vec2>;
    GetLocalCenter(): Readonly<Vec2>;
    SetLinearVelocity(v: XY): void;
    GetLinearVelocity(): Readonly<Vec2>;
    SetAngularVelocity(w: number): void;
    GetAngularVelocity(): number;
    GetDefinition(bd: BodyDef): BodyDef;
    ApplyForce(force: XY, point: XY, wake?: boolean): void;
    ApplyForceToCenter(force: XY, wake?: boolean): void;
    ApplyTorque(torque: number, wake?: boolean): void;
    ApplyLinearImpulse(impulse: XY, point: XY, wake?: boolean): void;
    ApplyLinearImpulseToCenter(impulse: XY, wake?: boolean): void;
    ApplyAngularImpulse(impulse: number, wake?: boolean): void;
    GetMass(): number;
    GetInertia(): number;
    GetMassData(data: MassData): MassData;
    SetMassData(massData: MassData): void;
    ResetMassData(): void;
    GetWorldPoint<T extends XY>(localPoint: XY, out: T): T;
    GetWorldVector<T extends XY>(localVector: XY, out: T): T;
    GetLocalPoint<T extends XY>(worldPoint: XY, out: T): T;
    GetLocalVector<T extends XY>(worldVector: XY, out: T): T;
    GetLinearVelocityFromWorldPoint<T extends XY>(worldPoint: XY, out: T): T;
    GetLinearVelocityFromLocalPoint<T extends XY>(localPoint: XY, out: T): T;
    GetLinearDamping(): number;
    SetLinearDamping(linearDamping: number): void;
    GetAngularDamping(): number;
    SetAngularDamping(angularDamping: number): void;
    GetGravityScale(): number;
    SetGravityScale(scale: number): void;
    SetType(type: BodyType): void;
    GetType(): BodyType;
    SetBullet(flag: boolean): void;
    IsBullet(): boolean;
    SetSleepingAllowed(flag: boolean): void;
    IsSleepingAllowed(): boolean;
    SetAwake(flag: boolean): void;
    IsAwake(): boolean;
    SetActive(flag: boolean): void;
    IsActive(): boolean;
    SetFixedRotation(flag: boolean): void;
    IsFixedRotation(): boolean;
    GetFixtureList(): Fixture | null;
    GetJointList(): JointEdge | null;
    GetContactList(): ContactEdge | null;
    GetNext(): Body | null;
    GetUserData(): any;
    SetUserData(data: any): void;
    GetWorld(): World;
    Dump(log: (format: string, ...args: any[]) => void): void;
    SynchronizeFixtures(): void;
    SynchronizeTransform(): void;
    ShouldCollide(other: Body): boolean;
    ShouldCollideConnected(other: Body): boolean;
    Advance(alpha: number): void;
    GetControllerList(): ControllerEdge | null;
    GetControllerCount(): number;
}
