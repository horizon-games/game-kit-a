import { Transform, Vec2, XY } from '../../Common/Math';
import { AABB, RayCastInput, RayCastOutput } from '../Collision';
import { DistanceProxy } from '../Distance';
import { MassData, Shape } from './Shape';
export declare class PolygonShape extends Shape {
    static ComputeCentroid(vs: Vec2[], count: number, out: Vec2): Vec2;
    private static Set_s_r;
    private static Set_s_v;
    private static TestPoint_s_pLocal;
    private static ComputeDistance_s_pLocal;
    private static ComputeDistance_s_normalForMaxDistance;
    private static ComputeDistance_s_minDistance;
    private static ComputeDistance_s_distance;
    private static RayCast_s_p1;
    private static RayCast_s_p2;
    private static RayCast_s_d;
    private static ComputeAABB_s_v;
    private static ComputeMass_s_center;
    private static ComputeMass_s_s;
    private static ComputeMass_s_e1;
    private static ComputeMass_s_e2;
    private static Validate_s_e;
    private static Validate_s_v;
    private static ComputeSubmergedArea_s_normalL;
    private static ComputeSubmergedArea_s_md;
    private static ComputeSubmergedArea_s_intoVec;
    private static ComputeSubmergedArea_s_outoVec;
    private static ComputeSubmergedArea_s_center;
    private static ComputeCentroid_s_pRef;
    private static ComputeCentroid_s_e1;
    private static ComputeCentroid_s_e2;
    readonly m_centroid: Vec2;
    m_vertices: Vec2[];
    m_normals: Vec2[];
    m_count: number;
    constructor();
    Clone(): PolygonShape;
    Copy(other: PolygonShape): PolygonShape;
    GetChildCount(): number;
    Set(vertices: XY[], count?: number, start?: number): PolygonShape;
    SetAsArray(vertices: XY[], count?: number): PolygonShape;
    SetAsBox(hx: number, hy: number, center?: XY, angle?: number): PolygonShape;
    TestPoint(xf: Transform, p: Vec2): boolean;
    ComputeDistance(xf: Transform, p: Vec2, normal: Vec2, childIndex: number): number;
    RayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean;
    ComputeAABB(aabb: AABB, xf: Transform, childIndex: number): void;
    ComputeMass(massData: MassData, density: number): void;
    Validate(): boolean;
    SetupDistanceProxy(proxy: DistanceProxy, index: number): void;
    ComputeSubmergedArea(normal: Vec2, offset: number, xf: Transform, c: Vec2): number;
    Dump(log: (format: string, ...args: any[]) => void): void;
}
